<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Items Browser Mockup</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'Segoe UI', system-ui, sans-serif;
    background: #1a1a2e;
    color: #e0e0e0;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }

  /* === TOP BAR === */
  .topbar {
    background: #0f0f23;
    border-bottom: 1px solid #2a2a4a;
    padding: 0.6rem 1.2rem;
    display: flex;
    align-items: center;
    gap: 1rem;
    position: sticky;
    top: 0;
    z-index: 100;
  }
  .breadcrumb { font-size: 0.9rem; color: #888; flex-shrink: 0; }
  .breadcrumb a { color: #6db3f2; text-decoration: none; }
  .breadcrumb a:hover { text-decoration: underline; }
  .breadcrumb .sep { margin: 0 0.3rem; color: #555; }

  .search-box { flex: 1; max-width: 400px; margin-left: auto; }
  .search-box input {
    width: 100%;
    padding: 0.4rem 0.8rem;
    background: #16213e;
    border: 1px solid #2a2a4a;
    border-radius: 4px;
    color: #e0e0e0;
    font-size: 0.85rem;
  }
  .search-box input::placeholder { color: #666; }
  .search-box input:focus { outline: none; border-color: #ffd700; }

  .gear-btn {
    background: none;
    border: 1px solid #2a2a4a;
    color: #888;
    padding: 0.35rem 0.6rem;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
  }
  .gear-btn:hover { color: #ffd700; border-color: #ffd700; }
  .gear-btn.active { color: #ffd700; border-color: #ffd700; }

  /* === OUTER LAYOUT === */
  .outer-layout { display: flex; flex: 1; min-height: 0; }

  /* === SIDEBAR === */
  .sidebar {
    width: 260px;
    background: #141428;
    border-right: 1px solid #2a2a4a;
    padding: 1rem;
    overflow-y: auto;
    flex-shrink: 0;
    display: none;
  }
  .sidebar.open { display: block; }
  .sidebar h3 {
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: #666;
    margin-bottom: 0.5rem;
  }
  .sidebar label {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    font-size: 0.85rem;
    padding: 0.2rem 0;
    cursor: pointer;
  }
  .sidebar label:hover { color: #fff; }
  .sidebar input[type="checkbox"] { accent-color: #ffd700; }
  .sidebar .section + .section { margin-top: 1.2rem; }
  .sidebar .filter-group { margin-top: 0.5rem; }

  /* Column config */
  .col-list { list-style: none; }
  .col-item {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    padding: 0.3rem 0.4rem;
    border-radius: 4px;
    font-size: 0.85rem;
    cursor: grab;
    user-select: none;
  }
  .col-item:hover { background: #1c2844; }
  .col-item.dragging { opacity: 0.4; }
  .col-item .drag-handle { color: #444; cursor: grab; font-size: 0.75rem; line-height: 1; }
  .col-item .drag-handle:hover { color: #888; }
  .col-item .col-label { flex: 1; color: #ccc; }
  .col-item .remove-btn {
    color: #666; cursor: pointer; font-size: 0.9rem;
    width: 1.2rem; text-align: center; border-radius: 3px; line-height: 1.2rem;
  }
  .col-item .remove-btn:hover { color: #e34f4f; background: rgba(227, 79, 79, 0.15); }

  .add-col-btn {
    display: inline-flex; align-items: center; gap: 0.3rem;
    margin-top: 0.4rem; padding: 0.25rem 0.6rem;
    background: none; border: 1px dashed #2a2a4a; border-radius: 4px;
    color: #666; cursor: pointer; font-size: 0.8rem;
  }
  .add-col-btn:hover { color: #ffd700; border-color: #ffd700; }

  .add-col-input-wrap { margin-top: 0.4rem; position: relative; }
  .add-col-input-wrap input {
    width: 100%; padding: 0.35rem 0.6rem;
    background: #16213e; border: 1px solid #2a2a4a; border-radius: 4px;
    color: #e0e0e0; font-size: 0.8rem;
  }
  .add-col-input-wrap input:focus { outline: none; border-color: #ffd700; }
  .autocomplete-list {
    position: absolute; top: 100%; left: 0; right: 0;
    background: #16213e; border: 1px solid #2a2a4a; border-top: none;
    border-radius: 0 0 4px 4px; max-height: 160px; overflow-y: auto; z-index: 10;
  }
  .autocomplete-item { padding: 0.35rem 0.6rem; cursor: pointer; font-size: 0.8rem; }
  .autocomplete-item:hover { background: #1c2844; color: #ffd700; }
  .autocomplete-item .ac-key { color: #555; font-size: 0.7rem; margin-left: 0.5rem; }

  .col-path-hint { font-size: 0.7rem; color: #555; margin-bottom: 0.3rem; font-style: italic; }

  /* Column target selector (overview mode) */
  .col-target-select {
    width: 100%; padding: 0.35rem 0.5rem; margin-bottom: 0.5rem;
    background: #16213e; border: 1px solid #2a2a4a; border-radius: 4px;
    color: #e0e0e0; font-size: 0.8rem;
  }
  .col-target-select:focus { outline: none; border-color: #ffd700; }

  /* === RIGHT PANEL === */
  .right-panel { flex: 1; display: flex; flex-direction: column; min-width: 0; }

  /* === TABS === */
  .tabs {
    display: flex; background: #141428; border-bottom: 2px solid #2a2a4a;
    overflow-x: auto; padding: 0 1rem; flex-shrink: 0;
  }
  .tab {
    padding: 0.6rem 1.2rem; cursor: pointer; color: #888; font-size: 0.85rem;
    border-bottom: 2px solid transparent; margin-bottom: -2px;
    white-space: nowrap; transition: color 0.15s, border-color 0.15s; user-select: none;
  }
  .tab:hover { color: #ccc; }
  .tab.active { color: #ffd700; border-bottom-color: #ffd700; }
  .tab .count { font-size: 0.7rem; color: #555; margin-left: 0.3rem; }
  .tab.active .count { color: #b8960a; }
  /* "All" tab */
  .tab.all-tab { font-style: italic; }

  /* === CONTENT === */
  .content { flex: 1; padding: 1.2rem; overflow: auto; }

  /* Subcategory chips */
  .subcategories { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 1.2rem; }
  .subcat-chip {
    background: #16213e; border: 1px solid #2a2a4a; border-radius: 6px;
    padding: 0.4rem 0.8rem; cursor: pointer; font-size: 0.85rem;
    color: #b0b0b0; transition: all 0.15s; text-decoration: none;
  }
  .subcat-chip:hover { border-color: #ffd700; color: #ffd700; background: #1c2844; }
  .subcat-chip .chip-count { font-size: 0.7rem; color: #555; margin-left: 0.3rem; }
  .subcat-chip:hover .chip-count { color: #b8960a; }

  .result-info { font-size: 0.8rem; color: #666; margin-bottom: 0.8rem; }

  /* === TABLE (shared) === */
  table { width: 100%; border-collapse: collapse; font-size: 0.85rem; }
  thead th {
    position: sticky; top: 0; background: #0f0f23; text-align: left;
    padding: 0.5rem 0.8rem; color: #999; font-weight: 600; font-size: 0.75rem;
    text-transform: uppercase; letter-spacing: 0.04em;
    border-bottom: 1px solid #2a2a4a; cursor: pointer; user-select: none; white-space: nowrap;
  }
  thead th:hover { color: #ffd700; }
  thead th .sort-arrow { margin-left: 0.3rem; font-size: 0.65rem; }

  /* Column filter row */
  .filter-row th {
    padding: 0.25rem 0.4rem;
    background: #0f0f23;
    border-bottom: 1px solid #2a2a4a;
    cursor: default;
  }
  .filter-row th:hover { color: #999; }
  .col-filter {
    width: 100%;
    padding: 0.25rem 0.4rem;
    background: #16213e;
    border: 1px solid #1e1e3a;
    border-radius: 3px;
    color: #e0e0e0;
    font-size: 0.75rem;
    font-weight: normal;
    text-transform: none;
    letter-spacing: normal;
  }
  .col-filter::placeholder { color: #444; }
  .col-filter:focus { outline: none; border-color: #ffd700; }
  .col-filter.active { border-color: #4a4a00; background: #1a2030; }

  tbody tr { border-bottom: 1px solid #1e1e3a; transition: background 0.1s; }
  tbody tr:hover { background: #1c2844; }
  td { padding: 0.45rem 0.8rem; white-space: nowrap; }
  td.id-cell, th.id-col { width: 1%; white-space: nowrap; }
  td.name-cell { color: #e0e0e0; font-weight: 500; }
  td.type-cell { color: #888; }
  td.num-cell { font-variant-numeric: tabular-nums; }

  /* Rarity */
  .rarity-Common { color: #b0b0b0; }
  .rarity-Uncommon { color: #6bc74f; }
  .rarity-Rare { color: #4fa7e3; }
  .rarity-Epic { color: #c35de3; }
  .rarity-Legendary { color: #ffd700; }
  .rarity-Mythical { color: #e34f4f; }

  /* === MULTI-TABLE SECTIONS (overview mode) === */
  .table-section { margin-bottom: 2rem; }
  .table-section-header {
    display: flex; align-items: center; gap: 0.6rem;
    padding: 0.5rem 0; margin-bottom: 0.5rem;
    border-bottom: 1px solid #2a2a4a;
    cursor: pointer; user-select: none;
  }
  .table-section-header:hover .section-title { color: #ffd700; }
  .table-section-header .collapse-arrow {
    color: #555; font-size: 0.7rem; transition: transform 0.15s; width: 1rem; text-align: center;
  }
  .table-section-header.collapsed .collapse-arrow { transform: rotate(-90deg); }
  .section-title {
    font-size: 1rem; font-weight: 600; color: #ccc; transition: color 0.15s;
  }
  .section-count { font-size: 0.75rem; color: #555; }
  .section-drill {
    margin-left: auto; font-size: 0.75rem; color: #444;
    padding: 0.2rem 0.5rem; border: 1px solid transparent; border-radius: 3px;
    cursor: pointer; text-decoration: none;
  }
  .section-drill:hover { color: #6db3f2; border-color: #2a2a4a; }
  .table-section-body { overflow: hidden; }
  .table-section-header.collapsed + .table-section-body { display: none; }

  /* Scrollable table wrapper for overview sections */
  .table-wrap { max-height: 400px; overflow-y: auto; border: 1px solid #1e1e3a; border-radius: 4px; }
  .table-wrap table { margin: 0; }

  /* === RESPONSIVE === */
  @media (max-width: 800px) {
    .sidebar { position: fixed; left: 0; top: 44px; bottom: 0; z-index: 50; }
    .tab { padding: 0.5rem 0.8rem; font-size: 0.8rem; }
  }
</style>
</head>
<body>

<!-- TOP BAR -->
<div class="topbar">
  <div class="breadcrumb">
    <a href="/">stuff</a>
    <span class="sep">/</span>
    <a href="../">Unturned</a>
    <span class="sep">/</span>
    <a href="#" onclick="navigate([]); return false;">Items</a>
    <span id="breadcrumb-trail"></span>
  </div>
  <div class="search-box">
    <input type="text" id="search" placeholder="Search items..." oninput="applyFilters()">
  </div>
  <button class="gear-btn" id="gear-btn" onclick="toggleSidebar()" title="Settings">&#9881;</button>
</div>

<div class="outer-layout">
  <!-- SIDEBAR -->
  <div class="sidebar" id="sidebar">
    <div class="section">
      <h3>Visible Tables</h3>
      <div id="tab-toggles" class="filter-group"></div>
    </div>
    <div class="section">
      <h3>Map Filter</h3>
      <div id="map-filters" class="filter-group">
        <label><input type="checkbox" checked> All Maps</label>
        <label><input type="checkbox" checked> PEI</label>
        <label><input type="checkbox" checked> Washington</label>
        <label><input type="checkbox" checked> Russia</label>
        <label><input type="checkbox" checked> Germany</label>
        <label><input type="checkbox" checked> A6 Polaris</label>
      </div>
    </div>
    <div class="section">
      <h3>Columns</h3>
      <div id="col-target-area"></div>
      <div id="col-path-hint" class="col-path-hint"></div>
      <ul class="col-list" id="col-list"></ul>
      <div id="add-col-area"></div>
    </div>
  </div>

  <!-- RIGHT: tabs + content -->
  <div class="right-panel">
    <div class="tabs" id="tabs"></div>
    <div class="content" id="content"></div>
  </div>
</div>

<script>
// ============================================================
// FAKE DATA
// ============================================================
const ENTRIES = [
  { name: "Eaglefire", type: "Gun", id: 353, rarity: "Legendary", category: ["Items", "Guns"], parsed: { range: 200, firerate: 10, damage: { player: 40 } } },
  { name: "Maplestrike", type: "Gun", id: 363, rarity: "Legendary", category: ["Items", "Guns"], parsed: { range: 200, firerate: 9, damage: { player: 43 } } },
  { name: "Zubeknakov", type: "Gun", id: 122, rarity: "Rare", category: ["Items", "Guns"], parsed: { range: 200, firerate: 8, damage: { player: 40 } } },
  { name: "Hawkhound", type: "Gun", id: 109, rarity: "Uncommon", category: ["Items", "Guns"], parsed: { range: 200, firerate: 12, damage: { player: 80 } } },
  { name: "Colt", type: "Gun", id: 112, rarity: "Uncommon", category: ["Items", "Guns"], parsed: { range: 50, firerate: 7, damage: { player: 30 } } },
  { name: "Timberwolf", type: "Gun", id: 18, rarity: "Legendary", category: ["Items", "Guns"], parsed: { range: 300, firerate: 20, damage: { player: 99 } } },
  { name: "MRE", type: "Food", id: 81, rarity: "Rare", category: ["Items", "Food"], parsed: { consumable: { food: 80, water: 30, health: 0 } } },
  { name: "Canned Beans", type: "Food", id: 13, rarity: "Common", category: ["Items", "Food"], parsed: { consumable: { food: 50, water: 10, health: 0 } } },
  { name: "Berries", type: "Food", id: 252, rarity: "Common", category: ["Items", "Food"], parsed: { consumable: { food: 15, water: 10, health: 0 } } },
  { name: "Cooked Venison", type: "Food", id: 466, rarity: "Uncommon", category: ["Items", "Food"], parsed: { consumable: { food: 60, water: 0, health: 5 } } },
  { name: "Katana", type: "Melee", id: 139, rarity: "Epic", category: ["Items", "Melee"], parsed: { range: 1.75, strength: 1, damage: { player: 55 } } },
  { name: "Axe", type: "Melee", id: 16, rarity: "Common", category: ["Items", "Melee"], parsed: { range: 1.5, strength: 1, damage: { player: 35 } } },
  { name: "Baseball Bat", type: "Melee", id: 140, rarity: "Uncommon", category: ["Items", "Melee"], parsed: { range: 1.65, strength: 0.5, damage: { player: 30 } } },
  { name: "Metal Wall", type: "Barricade", id: 370, rarity: "Uncommon", category: ["Items", "Barricades"], parsed: { health: 600 } },
  { name: "Sandbag Wall", type: "Barricade", id: 366, rarity: "Common", category: ["Items", "Barricades"], parsed: { health: 400 } },
  { name: "Pirate Captain Hat", type: "Hat", id: 61001, rarity: "Rare", category: ["Items", "Outfits", "PirateCaptain"], parsed: { armor: 0.9 } },
  { name: "Pirate Captain Coat", type: "Shirt", id: 61002, rarity: "Rare", category: ["Items", "Outfits", "PirateCaptain"], parsed: { armor: 0.85, storage: { width: 4, height: 3 } } },
  { name: "Pirate Captain Boots", type: "Pants", id: 61003, rarity: "Rare", category: ["Items", "Outfits", "PirateCaptain"], parsed: { armor: 0.85 } },
  { name: "Beekeeper Hood", type: "Hat", id: 62001, rarity: "Uncommon", category: ["Items", "Outfits", "Beekeeper"], parsed: { armor: 0.95 } },
  { name: "Beekeeper Suit", type: "Shirt", id: 62002, rarity: "Uncommon", category: ["Items", "Outfits", "Beekeeper"], parsed: { armor: 0.9, storage: { width: 3, height: 3 } } },
  { name: "Alicepack", type: "Backpack", id: 253, rarity: "Rare", category: ["Items", "Backpacks"], parsed: { storage: { width: 8, height: 5 }, armor: 1.0 } },
  { name: "Travelpack", type: "Backpack", id: 201, rarity: "Uncommon", category: ["Items", "Backpacks"], parsed: { storage: { width: 5, height: 4 }, armor: 1.0 } },
  { name: "Offroader", type: "Vehicle", id: 1, rarity: "Common", category: ["Vehicles"], parsed: { speed_max: 14, fuel_capacity: 1500, health_max: 200, trunk_x: 6, trunk_y: 4 } },
  { name: "Sedan", type: "Vehicle", id: 3, rarity: "Common", category: ["Vehicles"], parsed: { speed_max: 16, fuel_capacity: 1200, health_max: 150, trunk_x: 4, trunk_y: 3 } },
  { name: "APC", type: "Vehicle", id: 53, rarity: "Legendary", category: ["Vehicles"], parsed: { speed_max: 12, fuel_capacity: 2500, health_max: 1000, trunk_x: 8, trunk_y: 6 } },
  { name: "Helicopter", type: "Vehicle", id: 100, rarity: "Epic", category: ["Vehicles"], parsed: { speed_max: 20, fuel_capacity: 3000, health_max: 300 } },
  { name: "Bear", type: "Animal", id: 5, rarity: "Common", category: ["Animals"], parsed: { health: 150, damage: 30, speed_run: 8 } },
  { name: "Deer", type: "Animal", id: 1, rarity: "Common", category: ["Animals"], parsed: { health: 50, damage: 0, speed_run: 10 } },
  { name: "Wolf", type: "Animal", id: 3, rarity: "Common", category: ["Animals"], parsed: { health: 80, damage: 20, speed_run: 9 } },
  { name: "Civilian", type: "Spawn", id: 228, rarity: "Common", category: ["Spawns", "Items"], parsed: { table_entries: [{ref_id: 13}, {ref_id: 16}] } },
  { name: "Military_Low", type: "Spawn", id: 230, rarity: "Common", category: ["Spawns", "Items"], parsed: { table_entries: [{ref_id: 353}, {ref_id: 363}] } },
];

// ============================================================
// COLUMN DEFAULTS
// ============================================================
const DEFAULT_COLUMNS = {
  "": [
    { key: "id", label: "ID" }, { key: "name", label: "Name" },
    { key: "type", label: "Type" }, { key: "rarity", label: "Rarity" },
  ],
  "Items": [
    { key: "id", label: "ID" }, { key: "name", label: "Name" },
    { key: "type", label: "Type" }, { key: "rarity", label: "Rarity" },
  ],
  "Items/Guns": [
    { key: "id", label: "ID" }, { key: "name", label: "Name" }, { key: "rarity", label: "Rarity" },
    { key: "parsed.range", label: "Range" }, { key: "parsed.firerate", label: "Firerate" },
    { key: "parsed.damage.player", label: "Damage" },
  ],
  "Items/Food": [
    { key: "id", label: "ID" }, { key: "name", label: "Name" }, { key: "rarity", label: "Rarity" },
    { key: "parsed.consumable.food", label: "Food" }, { key: "parsed.consumable.water", label: "Water" },
    { key: "parsed.consumable.health", label: "Health" },
  ],
  "Items/Melee": [
    { key: "id", label: "ID" }, { key: "name", label: "Name" }, { key: "rarity", label: "Rarity" },
    { key: "parsed.range", label: "Range" }, { key: "parsed.damage.player", label: "Damage" },
  ],
  "Items/Backpacks": [
    { key: "id", label: "ID" }, { key: "name", label: "Name" }, { key: "rarity", label: "Rarity" },
    { key: "parsed.storage.width", label: "Width" }, { key: "parsed.storage.height", label: "Height" },
    { key: "parsed.armor", label: "Armor" },
  ],
  "Vehicles": [
    { key: "id", label: "ID" }, { key: "name", label: "Name" }, { key: "rarity", label: "Rarity" },
    { key: "parsed.speed_max", label: "Speed" }, { key: "parsed.fuel_capacity", label: "Fuel Cap" },
    { key: "parsed.health_max", label: "Health" }, { key: "parsed.trunk_x", label: "Trunk W" },
    { key: "parsed.trunk_y", label: "Trunk H" },
  ],
  "Animals": [
    { key: "id", label: "ID" }, { key: "name", label: "Name" },
    { key: "parsed.health", label: "Health" }, { key: "parsed.damage", label: "Damage" },
    { key: "parsed.speed_run", label: "Speed" },
  ],
};

const ALL_COLUMNS = [
  { key: "name", label: "Name" }, { key: "id", label: "ID" },
  { key: "type", label: "Type" }, { key: "rarity", label: "Rarity" },
  { key: "description", label: "Description" },
  { key: "parsed.range", label: "Range" }, { key: "parsed.firerate", label: "Firerate" },
  { key: "parsed.damage.player", label: "Player Damage" },
  { key: "parsed.damage.zombie", label: "Zombie Damage" },
  { key: "parsed.damage.animal", label: "Animal Damage" },
  { key: "parsed.damage.barricade", label: "Barricade Damage" },
  { key: "parsed.damage.structure", label: "Structure Damage" },
  { key: "parsed.damage.vehicle", label: "Vehicle Damage" },
  { key: "parsed.consumable.food", label: "Food" },
  { key: "parsed.consumable.water", label: "Water" },
  { key: "parsed.consumable.health", label: "Health Restored" },
  { key: "parsed.consumable.virus", label: "Virus" },
  { key: "parsed.health", label: "Health" }, { key: "parsed.armor", label: "Armor" },
  { key: "parsed.storage.width", label: "Storage Width" },
  { key: "parsed.storage.height", label: "Storage Height" },
  { key: "parsed.speed_max", label: "Max Speed" },
  { key: "parsed.fuel_capacity", label: "Fuel Capacity" },
  { key: "parsed.health_max", label: "Max Health" },
  { key: "parsed.trunk_x", label: "Trunk Width" },
  { key: "parsed.trunk_y", label: "Trunk Height" },
  { key: "parsed.strength", label: "Strength" }, { key: "parsed.stamina", label: "Stamina" },
  { key: "parsed.durability", label: "Durability" }, { key: "parsed.speed_run", label: "Run Speed" },
  { key: "parsed.slot", label: "Slot" }, { key: "size_x", label: "Size X" },
  { key: "size_y", label: "Size Y" },
];

// ============================================================
// STATE
// ============================================================
let currentPath = [];       // [] = overview mode, ["Items"] = focused, ["Items","Guns"] = drilled
let activeTab = null;
let sortState = {};         // pathKey -> { col, dir }
let addingColumn = false;
let colEditTarget = null;   // pathKey of the category whose columns we're editing in sidebar

// localStorage: column overrides & hidden tables & collapsed sections
let columnOverrides = {};
let hiddenTables = {};      // catName -> true
let collapsedSections = {}; // catName -> true
try { columnOverrides = JSON.parse(localStorage.getItem("ut-items:cols") || "{}"); } catch {}
try { hiddenTables = JSON.parse(localStorage.getItem("ut-items:hidden") || "{}"); } catch {}
try { collapsedSections = JSON.parse(localStorage.getItem("ut-items:collapsed") || "{}"); } catch {}

function saveState() {
  localStorage.setItem("ut-items:cols", JSON.stringify(columnOverrides));
  localStorage.setItem("ut-items:hidden", JSON.stringify(hiddenTables));
  localStorage.setItem("ut-items:collapsed", JSON.stringify(collapsedSections));
}

// ============================================================
// HELPERS
// ============================================================
function getNestedValue(obj, path) {
  let v = obj;
  for (const p of path.split(".")) { if (v == null) return undefined; v = v[p]; }
  return v;
}

function pathStartsWith(entryPath, prefix) {
  if (prefix.length > entryPath.length) return false;
  for (let i = 0; i < prefix.length; i++) if (entryPath[i] !== prefix[i]) return false;
  return true;
}

function getEntriesAtPath(path) {
  return ENTRIES.filter(e => pathStartsWith(e.category, path));
}

function getSubcategories(path, entries) {
  const depth = path.length;
  const subs = new Map();
  for (const e of entries) {
    if (e.category.length > depth) subs.set(e.category[depth], (subs.get(e.category[depth]) || 0) + 1);
  }
  return [...subs.entries()].sort((a, b) => a[0].localeCompare(b[0]));
}

function getTopLevelCategories() {
  const cats = new Map();
  for (const e of ENTRIES) {
    if (e.category.length > 0) cats.set(e.category[0], (cats.get(e.category[0]) || 0) + 1);
  }
  return [...cats.entries()].sort((a, b) => b[1] - a[1]);
}

function pk(path) { return path.join("/"); }

function getColumnsForPath(path) {
  for (let i = path.length; i >= 0; i--) {
    const key = pk(path.slice(0, i));
    if (columnOverrides[key]) return { columns: columnOverrides[key], fromPath: key, isOverride: true };
  }
  for (let i = path.length; i >= 0; i--) {
    const key = pk(path.slice(0, i));
    if (DEFAULT_COLUMNS[key]) return { columns: DEFAULT_COLUMNS[key], fromPath: key, isOverride: false };
  }
  return { columns: DEFAULT_COLUMNS[""], fromPath: "", isOverride: false };
}

function isOverviewMode() { return currentPath.length === 0; }

function getSort(pathKey) { return sortState[pathKey] || { col: null, dir: 1 }; }

function searchFilter(entries) {
  const q = document.getElementById("search").value.toLowerCase();
  if (!q) return entries;
  return entries.filter(e =>
    e.name.toLowerCase().includes(q) || e.type.toLowerCase().includes(q) || String(e.id).includes(q)
  );
}

// Column filter state: pathKey -> { colKey: filterString }
let colFilters = {};

function parseFilter(raw) {
  // Returns { op, value } or null if empty
  const s = raw.trim();
  if (!s) return null;
  // Numeric operators: >=, <=, !=, >, <, =
  const m = s.match(/^(>=|<=|!=|>|<|=)\s*(.+)/);
  if (m) {
    const num = parseFloat(m[2]);
    if (!isNaN(num)) return { op: m[1], value: num };
  }
  // Plain number -> exact match
  const num = parseFloat(s);
  if (!isNaN(num) && s === String(num)) return { op: "=", value: num };
  // Text substring
  return { op: "~", value: s.toLowerCase() };
}

function matchesFilter(cellValue, filter) {
  if (!filter) return true;
  if (filter.op === "~") {
    return cellValue != null && String(cellValue).toLowerCase().includes(filter.value);
  }
  // Numeric comparisons
  const n = typeof cellValue === "number" ? cellValue : parseFloat(cellValue);
  if (isNaN(n)) return false;
  switch (filter.op) {
    case ">":  return n > filter.value;
    case "<":  return n < filter.value;
    case ">=": return n >= filter.value;
    case "<=": return n <= filter.value;
    case "!=": return n !== filter.value;
    case "=":  return n === filter.value;
  }
  return true;
}

function applyColFilters(entries, columns, pathKey) {
  const filters = colFilters[pathKey];
  if (!filters) return entries;
  const active = columns.map(c => ({ key: c.key, filter: parseFilter(filters[c.key] || "") }))
                        .filter(f => f.filter);
  if (active.length === 0) return entries;
  return entries.filter(e => active.every(({ key, filter }) => matchesFilter(getNestedValue(e, key), filter)));
}

// ============================================================
// TABLE HTML BUILDER (reused for both modes)
// ============================================================
function buildTableHTML(entries, columns, sortKey, sortDir, pathKeyForSort) {
  let sorted = [...entries];
  if (sortKey) {
    sorted.sort((a, b) => {
      let va = getNestedValue(a, sortKey), vb = getNestedValue(b, sortKey);
      if (va == null) va = ""; if (vb == null) vb = "";
      if (typeof va === "number" && typeof vb === "number") return (va - vb) * sortDir;
      return String(va).localeCompare(String(vb)) * sortDir;
    });
  }
  sorted = searchFilter(sorted);
  sorted = applyColFilters(sorted, columns, pathKeyForSort);

  const esc = s => String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;");
  const filters = colFilters[pathKeyForSort] || {};

  const headerRow = `<tr>${columns.map(c => {
    const arrow = sortKey === c.key ? (sortDir === 1 ? "&#9650;" : "&#9660;") : "";
    const thCls = c.key === "id" ? ' class="id-col"' : "";
    return `<th${thCls} onclick="doSort('${pathKeyForSort}','${c.key}')">${esc(c.label)}<span class="sort-arrow">${arrow}</span></th>`;
  }).join("")}</tr>`;

  const filterRow = `<tr class="filter-row">${columns.map(c => {
    const val = esc(filters[c.key] || "");
    const isActive = val ? "active" : "";
    const placeholder = isNumericColumn(c.key, entries) ? "&gt;, &lt;, =..." : "filter...";
    return `<th><input class="col-filter ${isActive}" type="text" value="${val}"
      placeholder="${placeholder}"
      data-pathkey="${pathKeyForSort}" data-colkey="${c.key}"
      oninput="onColFilter(this)" /></th>`;
  }).join("")}</tr>`;

  const thead = headerRow + filterRow;

  const tbody = sorted.map(e => `<tr>${columns.map(c => {
    let val = getNestedValue(e, c.key);
    if (val == null) val = "\u2014";
    const isNum = typeof val === "number";
    const cls = c.key === "id" ? "id-cell" : c.key === "name" ? "name-cell" : c.key === "type" ? "type-cell" : isNum ? "num-cell" : "";
    const rar = c.key === "rarity" ? `rarity-${val}` : "";
    return `<td class="${cls} ${rar}">${esc(val)}</td>`;
  }).join("")}</tr>`).join("");

  return { thead, tbody, visibleCount: sorted.length, totalCount: entries.length };
}

function isNumericColumn(colKey, entries) {
  // Sample a few entries to guess if this column is numeric
  let numCount = 0;
  for (let i = 0; i < Math.min(entries.length, 10); i++) {
    const v = getNestedValue(entries[i], colKey);
    if (typeof v === "number") numCount++;
  }
  return numCount > 0;
}

function onColFilter(input) {
  const pathKey = input.dataset.pathkey;
  const colKey = input.dataset.colkey;
  if (!colFilters[pathKey]) colFilters[pathKey] = {};
  colFilters[pathKey][colKey] = input.value;
  input.classList.toggle("active", input.value.trim().length > 0);
  render();
  // Restore focus to the input after re-render
  requestAnimationFrame(() => {
    const el = document.querySelector(`input[data-pathkey="${pathKey}"][data-colkey="${colKey}"]`);
    if (el) { el.focus(); el.selectionStart = el.selectionEnd = el.value.length; }
  });
}

// ============================================================
// RENDER
// ============================================================
function renderTabs() {
  const tabsEl = document.getElementById("tabs");
  const cats = getTopLevelCategories();
  const allTab = `<div class="tab all-tab ${isOverviewMode() ? 'active' : ''}" onclick="navigate([])">
    All<span class="count">${ENTRIES.length}</span></div>`;
  const catTabs = cats.map(([name, count]) => `
    <div class="tab ${activeTab === name ? 'active' : ''}" onclick="navigate(['${name}'])">
      ${name}<span class="count">${count}</span>
    </div>`).join("");
  tabsEl.innerHTML = allTab + catTabs;
}

function renderBreadcrumb() {
  const trail = document.getElementById("breadcrumb-trail");
  if (currentPath.length === 0) { trail.innerHTML = ""; return; }
  let html = "";
  for (let i = 0; i < currentPath.length; i++) {
    const sub = currentPath.slice(0, i + 1);
    const isLast = i === currentPath.length - 1;
    html += `<span class="sep">/</span>`;
    html += isLast
      ? `<span style="color:#e0e0e0">${currentPath[i]}</span>`
      : `<a href="#" onclick="navigate(${JSON.stringify(sub)});return false;">${currentPath[i]}</a>`;
  }
  trail.innerHTML = html;
}

function renderCategoryToggles() {
  const el = document.getElementById("tab-toggles");
  const cats = getTopLevelCategories();
  el.innerHTML = cats.map(([name, count]) => `
    <label>
      <input type="checkbox" ${hiddenTables[name] ? '' : 'checked'}
             onchange="toggleTableVisibility('${name}', this.checked)">
      ${name} <span style="color:#555;font-size:0.75rem">(${count})</span>
    </label>
  `).join("");
}

function renderOverviewMode() {
  const content = document.getElementById("content");
  const cats = getTopLevelCategories();
  let html = "";

  for (const [catName, count] of cats) {
    if (hiddenTables[catName]) continue;

    const catPath = [catName];
    const entries = getEntriesAtPath(catPath);
    const { columns } = getColumnsForPath(catPath);
    const s = getSort(catName);
    const { thead, tbody, visibleCount, totalCount } = buildTableHTML(entries, columns, s.col, s.dir, catName);
    const collapsed = collapsedSections[catName];

    html += `
      <div class="table-section" id="section-${catName}">
        <div class="table-section-header ${collapsed ? 'collapsed' : ''}"
             onclick="toggleCollapse('${catName}')">
          <span class="collapse-arrow">&#9660;</span>
          <span class="section-title">${catName}</span>
          <span class="section-count">${visibleCount} / ${totalCount}</span>
          <a class="section-drill" href="#" onclick="event.stopPropagation();navigate(['${catName}']);return false;">
            Open &rarr;
          </a>
        </div>
        <div class="table-section-body">
          <div class="table-wrap">
            <table><thead>${thead}</thead><tbody>${tbody}</tbody></table>
          </div>
        </div>
      </div>`;
  }
  content.innerHTML = html;
}

function renderFocusedMode() {
  const content = document.getElementById("content");
  const entries = getEntriesAtPath(currentPath);
  const subs = getSubcategories(currentPath, entries);
  const { columns } = getColumnsForPath(currentPath);
  const key = pk(currentPath);
  const s = getSort(key);
  const { thead, tbody, visibleCount, totalCount } = buildTableHTML(entries, columns, s.col, s.dir, key);

  let html = "";

  // Subcat chips
  if (subs.length > 0) {
    html += `<div class="subcategories">${subs.map(([name, count]) => {
      const path = [...currentPath, name];
      return `<a class="subcat-chip" href="#" onclick="navigate(${JSON.stringify(path)});return false;">
        ${name}<span class="chip-count">${count}</span></a>`;
    }).join("")}</div>`;
  }

  html += `<div class="result-info">${visibleCount} of ${totalCount} entries in ${currentPath.join(" > ")}</div>`;
  html += `<table><thead>${thead}</thead><tbody>${tbody}</tbody></table>`;
  content.innerHTML = html;
}

// ============================================================
// COLUMN CONFIG SIDEBAR
// ============================================================
let dragSrcIdx = null;

function getColEditPath() {
  if (!isOverviewMode()) return currentPath;
  // In overview mode, use the selected target (default: first visible cat)
  if (colEditTarget !== null) return colEditTarget.split("/").filter(Boolean);
  const cats = getTopLevelCategories();
  for (const [name] of cats) { if (!hiddenTables[name]) return [name]; }
  return [];
}

function renderColumnConfig() {
  const editPath = getColEditPath();
  const editKey = pk(editPath);
  const { columns, fromPath, isOverride } = getColumnsForPath(editPath);

  // In overview mode, show a dropdown to pick which table to configure
  const targetArea = document.getElementById("col-target-area");
  if (isOverviewMode()) {
    const cats = getTopLevelCategories().filter(([n]) => !hiddenTables[n]);
    targetArea.innerHTML = `<select class="col-target-select" onchange="colEditTarget=this.value;renderColumnConfig();">
      ${cats.map(([name]) => `<option value="${name}" ${editKey === name ? 'selected' : ''}>${name}</option>`).join("")}
    </select>`;
  } else {
    targetArea.innerHTML = "";
  }

  const hint = document.getElementById("col-path-hint");
  if (fromPath === editKey) {
    hint.textContent = isOverride ? "Custom (modified)" : "";
  } else {
    hint.textContent = `Inherited from ${fromPath || "root"}`;
  }

  const list = document.getElementById("col-list");
  list.innerHTML = columns.map((col, i) => `
    <li class="col-item" draggable="true" data-idx="${i}"
        ondragstart="onColDragStart(event,${i})" ondragover="onColDragOver(event,${i})"
        ondrop="onColDrop(event,${i})" ondragend="onColDragEnd(event)">
      <span class="drag-handle">&#9776;</span>
      <span class="col-label">${col.label}</span>
      <span class="remove-btn" onclick="removeColumn(${i})" title="Remove">&minus;</span>
    </li>`).join("");

  const addArea = document.getElementById("add-col-area");
  if (!addingColumn) {
    addArea.innerHTML = `<button class="add-col-btn" onclick="startAddColumn()">+ Add column</button>`;
  }
}

function startAddColumn() {
  addingColumn = true;
  const addArea = document.getElementById("add-col-area");
  addArea.innerHTML = `
    <div class="add-col-input-wrap">
      <input type="text" id="add-col-input" placeholder="Search columns..."
             oninput="filterAutocomplete()" onfocus="filterAutocomplete()"
             onkeydown="if(event.key==='Escape'){cancelAddColumn();}">
      <div class="autocomplete-list" id="autocomplete-list"></div>
    </div>`;
  document.getElementById("add-col-input").focus();
  filterAutocomplete();
  setTimeout(() => document.addEventListener("click", onAddColOutsideClick), 0);
}

function onAddColOutsideClick(e) {
  const wrap = document.querySelector(".add-col-input-wrap");
  if (wrap && !wrap.contains(e.target)) cancelAddColumn();
}

function cancelAddColumn() {
  addingColumn = false;
  document.removeEventListener("click", onAddColOutsideClick);
  renderColumnConfig();
}

function filterAutocomplete() {
  const input = document.getElementById("add-col-input");
  const q = input.value.toLowerCase();
  const editPath = getColEditPath();
  const { columns } = getColumnsForPath(editPath);
  const active = new Set(columns.map(c => c.key));
  const matches = ALL_COLUMNS.filter(c => !active.has(c.key) &&
    (c.label.toLowerCase().includes(q) || c.key.toLowerCase().includes(q)));
  document.getElementById("autocomplete-list").innerHTML = matches.slice(0, 10).map(c => `
    <div class="autocomplete-item" onclick="addColumn('${c.key}','${c.label}')">
      ${c.label}<span class="ac-key">${c.key}</span></div>`).join("");
}

function addColumn(key, label) {
  const editPath = getColEditPath();
  const k = pk(editPath);
  const { columns } = getColumnsForPath(editPath);
  columnOverrides[k] = [...columns, { key, label }];
  saveState();
  addingColumn = false;
  document.removeEventListener("click", onAddColOutsideClick);
  render();
}

function removeColumn(idx) {
  const editPath = getColEditPath();
  const k = pk(editPath);
  const { columns } = getColumnsForPath(editPath);
  columnOverrides[k] = columns.filter((_, i) => i !== idx);
  saveState();
  render();
}

function onColDragStart(e, idx) { dragSrcIdx = idx; e.target.classList.add("dragging"); e.dataTransfer.effectAllowed = "move"; }
function onColDragOver(e) { e.preventDefault(); e.dataTransfer.dropEffect = "move"; }
function onColDrop(e, idx) {
  e.preventDefault();
  if (dragSrcIdx === null || dragSrcIdx === idx) return;
  const editPath = getColEditPath();
  const k = pk(editPath);
  const { columns } = getColumnsForPath(editPath);
  const cols = [...columns];
  const [moved] = cols.splice(dragSrcIdx, 1);
  cols.splice(idx, 0, moved);
  columnOverrides[k] = cols;
  saveState();
  dragSrcIdx = null;
  render();
}
function onColDragEnd(e) { e.target.classList.remove("dragging"); dragSrcIdx = null; }

// ============================================================
// ACTIONS
// ============================================================
function navigate(path) {
  currentPath = path;
  activeTab = path.length > 0 ? path[0] : null;
  addingColumn = false;
  colEditTarget = null;
  location.hash = path.length > 0 ? path.join("/") : "";
  render();
}

function doSort(pathKey, colKey) {
  const s = sortState[pathKey] || { col: null, dir: 1 };
  if (s.col === colKey) s.dir *= -1;
  else { s.col = colKey; s.dir = 1; }
  sortState[pathKey] = s;
  render();
}

function toggleTableVisibility(name, visible) {
  if (visible) delete hiddenTables[name];
  else hiddenTables[name] = true;
  saveState();
  render();
}

function toggleCollapse(catName) {
  if (collapsedSections[catName]) delete collapsedSections[catName];
  else collapsedSections[catName] = true;
  saveState();
  render();
}

function toggleSidebar() {
  document.getElementById("sidebar").classList.toggle("open");
  document.getElementById("gear-btn").classList.toggle("active");
}

function applyFilters() { render(); }

function render() {
  renderTabs();
  renderBreadcrumb();
  renderCategoryToggles();
  if (isOverviewMode()) renderOverviewMode();
  else renderFocusedMode();
  renderColumnConfig();
}

// ============================================================
// INIT
// ============================================================
window.addEventListener("hashchange", () => {
  const hash = decodeURIComponent(location.hash.slice(1));
  currentPath = hash ? hash.split("/") : [];
  activeTab = currentPath.length > 0 ? currentPath[0] : null;
  render();
});
const initHash = decodeURIComponent(location.hash.slice(1));
if (initHash) { currentPath = initHash.split("/"); activeTab = currentPath[0]; }
render();
</script>
</body>
</html>
